plutus-tx-plugin/src/Language/PlutusTx/Plugin.hs
===

installs two extra core-2-core passes, a very minimal simplifier pass to get unfoldings available, and the actual translation pass.

the second pass is in mkPluginPass which
  - compiles to PIR
  - then to PLC

ex:

 30 {-# INLINABLE plusOne #-}
 31 plusOne:: Integer -> Integer
 32 {- 'addInteger' comes from 'Language.PlutusTx.Builtins', and is
 33   mapped to the builtin integer addition function in Plutus Core. -}
 34 plusOne x = x `addInteger` 1
 35
 36 {-# INLINABLE myProgram #-}
 37 myProgram :: Integer
 38 myProgram =
 39     let
 40         -- Local functions do not need to be marked as 'INLINABLE'.
 41         plusOneLocal :: Integer -> Integer
 42         plusOneLocal x = x `addInteger` 1
 43
 44         localTwo = plusOneLocal 1
 45         externalTwo = plusOne 1
 46     in localTwo `addInteger` externalTwo
 47
 48 functions :: CompiledCode Integer
 49 functions = $$(compile [|| myProgram ||])


PIR
---
The used top-level lets are floated-in the program (here plusOne):


(program
  (let
    (nonrec)
    (termbind
      (strict)
      (vardecl plusOne (fun (con integer) (con integer)))
      (lam x (con integer) [ [ (builtin addInteger) x ] (con integer 1) ])
    )
    (termbind
      (nonstrict)
      (vardecl myProgram (con integer))
      [
        [
          (builtin addInteger)
          [ [ (builtin addInteger) (con integer 1) ] (con integer 1) ]
        ]
        [ plusOne (con integer 1) ]
      ]
    )
    myProgram
  )
)


PLC
---
Note that myProgram is transformed to :: (forall a . a -> a) -> Integer
Probably artifact of datatype translation? bound variable "arg" is unused
(abs = type lambda)

(program 1.0.0
  [
    (lam
      plusOne
      (fun (con integer) (con integer))
      [
        (lam
          myProgram
          (fun (all a (type) (fun a a)) (con integer))
          [ myProgram (abs a (type) (lam x a x)) ]
        )
        (lam
          arg
          (all a (type) (fun a a))
          [
            [
              (builtin addInteger)
              [ [ (builtin addInteger) (con integer 1) ] (con integer 1) ]
            ]
            [ plusOne (con integer 1) ]
          ]
        )
      ]
    )
    (lam x (con integer) [ [ (builtin addInteger) x ] (con integer 1) ])
  ]
)

