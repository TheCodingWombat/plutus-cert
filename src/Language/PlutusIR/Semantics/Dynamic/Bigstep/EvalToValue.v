Require Import PlutusCert.Language.PlutusIR.
Import NamedTerm.

Require Import PlutusCert.Language.PlutusIR.Semantics.Dynamic.Bigstep.


Lemma compute_defaultfun__to_value : forall t v,
    compute_defaultfun t = Datatypes.Some v ->
    value v.
Proof with (try discriminate).
  intros.
  destruct t...
  simpl in H.
  all: destruct t1...
  all: try destruct t1_1...
  all: try destruct t1_1_1...
  all: try destruct d...
  all: try destruct t1_1_2...
  all: try destruct s...
  all: try destruct u...
  all: try destruct v0...
  all: try destruct t1_2...
  all: try destruct s...
  all: try destruct u0...
  all: try destruct v0...
  all: try destruct t2...
  all: try destruct s...
  all: try destruct u1...
  all: try destruct v0...
  all: try (inversion H; subst)...
  all: autounfold.
  all: try solve [constructor].
  all: try destruct u...
  all: try (inversion H; subst)...
  all: autounfold.
  all: try constructor.
Qed.

Definition P_eval (t v : Term) (k : nat) := value v.
Definition P_eval_bindings_nonrec (t v : Term) (k : nat) := value v.
Definition P_eval_bindings_rec (bs0 : list Binding) (t v : Term) (k : nat) := value v.
#[export] Hint Unfold P_eval P_eval_bindings_nonrec P_eval_bindings_rec : core.

Lemma eval_to_value : forall t v k,
    t =[k]=> v -> value v.
Proof with eauto.
  eapply eval__ind with (P := P_eval) (P0 := P_eval_bindings_nonrec) (P1 := P_eval_bindings_rec).
  all: intros.
  all: autounfold.
  all: eauto using compute_defaultfun__to_value.
  - (* E_IWrap *)
    inversion H0...
    subst.
    inversion H1.
  - (* E_NeutralBuiltin *)
    destruct f...
    all: constructor...
    all: constructor...
    all: try solve [intros Hcon; inversion Hcon].
    all: unfold arity...
Qed.